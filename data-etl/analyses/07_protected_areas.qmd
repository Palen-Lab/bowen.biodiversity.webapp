---
title: "Protected Areas"
format: html
author: "Jay Matsushiba"
published: July 2 2025
date-modified: July 15 2025
---

# Protected Areas Candidates
First map / filter
- Public lands (crown, municipal, MV lands)
- Not in existing protected areas

Second map / filter
- Top 30% of conservation values 
- Wetland / water / riparian values
 
Algorithms in Zonation and Marxann for identifying these 
- Find cluster

```{r setup}
# Current package within which this vignette is included
library(bowen.biodiversity.webapp)
# Spatial 
library(sf)
library(terra)
library(tidyterra)
# Analysis / Plotting
library(dplyr)
library(tidyr)
library(ggplot2)
library(here)
# Google Sheets
library(googlesheets4)
# Prioritizr and deps
library(gurobi)
library(prioritizr)

caption <- paste0("Map created: ", date(), ". Palen Lab. Created by Jay Matsushiba (jmatsush@sfu.ca)")

output_dir <- here("vignettes/figures/protected_areas")
if(!dir.exists(output_dir)) {
  dir.create(output_dir)
}
```

## Input layers
```{r}
sdm_url <- "https://docs.google.com/spreadsheets/d/1IGFwkr9LidcZwbzOJJGSEXLsmpKp0a9gBs65EY-H1xw/edit?usp=sharing"
habitats_url <- "https://docs.google.com/spreadsheets/d/1yDKw4r3tbXYivwtxbbfxc-pYSbtbj_o2ee1pwlNCOO4/edit?usp=drive_link"


#### Zonation Raster Layers ####
# Load Zonation Output / Conservation Values
zonation <- here("inst/extdata/output_zonation/2025-06-30/rankmap.tif") %>%
  rast()
# For assessing freshwater habitat overlap with potential protected areas. 
# Read from Google Sheets
habitats_df <- read_sheet(habitats_url, sheet = "2025-06-30")
habitats_df$weight <- habitats_df$weight / nrow(habitats_df)
sdm_df <- read_sheet(sdm_url, sheet = "2025-06-30") 
sdm_df$weight <- sdm_df$weight / nrow(sdm_df)
# Bind all input layers together
layers_df <- sdm_df %>%
  select(colnames(habitats_df)) %>% # Select common columns
  bind_rows(habitats_df) %>%
  filter(weight > 0)


#### Vector Layers ####
parcels <- bowen.biodiversity.webapp::bowen_parcelmap %>%
  # filter(!OwnerType %in% c("Private", "Unclassified", "Mixed Ownership")) %>%
  filter(PID != 31243550) %>% # Remove ferry route 
  st_transform(st_crs(bowen_protectedareas))

parcels$geom <- parcels$geom %>%
  st_cast("MULTIPOLYGON") %>%
  st_make_valid()

bowen_protectedareas_valid <- bowen_protectedareas %>%
  st_make_valid()
```

## Parcels - Potential Protected Areas
### Public Land Parcels outside of Protected Areas 
This is the first filter for potential protected area candidates. We need to find public lands parcels that are not in existing protected areas. 
```{r}
# Dissolve protected areas into one geometry
dissolved_protectedareas <- bowen_protectedareas_valid %>%
  summarise() %>%
  st_cast() %>%
  st_buffer(1) # cleans up geometry slivers compared to 0, buffer distance in metres
# st_difference after 
# doing st_difference without dissolving protected areas into one geometry 
notprotected_parcels <- st_difference(parcels, dissolved_protectedareas)

# filter for public lands 
notprotected_parcels$OwnerType %>% unique()
# [1] "Private"          "Crown Provincial" "Local Government" "Mixed Ownership"  "Crown Agency"     "Federal"         
# [7] "Unclassified" 
notprotected_publiclands <- notprotected_parcels[!notprotected_parcels$OwnerType %in% c("Private", "Mixed Ownership", "Unclassified"),] 
notprotected_privatelands <- notprotected_parcels[notprotected_parcels$OwnerType %in% c("Private", "Mixed Ownership", "Unclassified"),] 
```

### Plotting Potential Protected Areas from Undeveloped Parcels 
```{r}
potential_protected_areas_ggfunc <- function() {
  protected_colour <- "#b3e2cd"
  notprotected_public_colour <-  "#fdcdac"
  notprotected_private_colour <- "#cbd5e8"
  output <- list(
    geom_sf(data = bowen_protectedareas_valid, aes(fill = protected_colour)),
    geom_sf(data = notprotected_publiclands, aes(fill = notprotected_public_colour)),
    geom_sf(data = notprotected_privatelands, aes(fill = notprotected_private_colour)),
    scale_fill_identity(name = "",
                          breaks = c(protected_colour, notprotected_public_colour, notprotected_private_colour),
                          labels = c("Protected", "Unprotected Public", "Unprotected Private"),
                          guide = "legend"
    ),
    ggnewscale::new_scale_fill(),
    ggnewscale::new_scale_colour()
  )
  return(output)
}

caption <- paste0("Map created: ", date(), ". Palen Lab. Created by Jay Matsushiba (jmatsush@sfu.ca)")
protected_areas_ggplot <- bowen_map_ggplot(
  potential_protected_areas_ggfunc,
  title = "Protected Areas and Parcels on Bowen Island",
  subtitle = "Mapping the Protected Areas and unprotected parcels to identify potential parcels for future protection.",
  caption = caption
)

ggplot2::ggsave(
  here(output_dir, "/", paste0(Sys.Date(), "_protected_areas_parcels.png")),
  protected_areas_ggplot,
  device = ragg::agg_png,
  width = 9, height = 12, units = "in", res = 300
)
```
### Conservation Values by Unprotected Public Parcel 
- Top 30% of conservation values 
- Wetland / water / riparian values
```{r}
#### Conservation values summed by parcel ####
# extract zonation raster values from cells within each parcel
notprotected_cons_vals <- notprotected_parcels %>% 
  vect() %>%
  terra::extract(zonation, ., 
                 sum, 
                 na.rm = TRUE, 
                 weights = TRUE, # sum biodiversity value by approx fraction of cell covered by polygon
                 bind = TRUE) 

#### Top 30% conservation values summed by parcel ####
# create top 30% zonation raster 
rcl <- matrix(c(
  0, 1, 1
), ncol = 3, byrow = T)
zonation_top_30 <- zonation %>%
  remove_by_quantile(
    prob = 0.7
  ) %>% 
  classify(rcl)
names(zonation_top_30) <- "rankmap_top_30"
# extract number of top conservation value cells within each parcel
notprotected_cons_1 <- notprotected_cons_vals %>%
  terra::extract(zonation_top_30, ., 
                 sum, 
                 na.rm = TRUE, 
                 weights = TRUE, # sum biodiversity value by approx fraction of cell covered by polygon
                 bind = TRUE) 

#### Freshwater (wetland, ponds, rivers) ####
# Get freshwater rasters, same used in zonation and data atlas
fw_df <- layers_df[layers_df$category == "Freshwater",]
fw_rast_stack <- layers_df[layers_df$category == "Freshwater", "path"] %>%
  unlist() %>%
  lapply(rast) %>%
  rast() 
fw_rast_stack %>% sources() # see order of paths 
names(fw_rast_stack) <- c("riparian", "streams", "lakes", "ponds", "wetlands") # assign names to layers
# TODO: decide what to do with stream classes, leave them as is?
# 3 is fish-bearing streams, 2 is tributary to fish-bearing, 1 is non-fishbearing / drainage channel / unclassified 

fw_richness <- fw_rast_stack %>%
  lapply(not.na) %>%
  lapply(function(x) {classify(x, cbind(FALSE, NA))}) %>%
  rast() %>%
  sum(na.rm = T) 
names(fw_richness) <- "fw_richness"
# summed richness by parcel
notprotected_cons_2 <- notprotected_cons_1 %>%
  terra::extract(fw_richness, ., 
                 sum, 
                 na.rm = TRUE, 
                 weights = TRUE, # sum biodiversity value by approx fraction of cell covered by polygon
                 bind = TRUE) 
notprotected_cons_2 <- notprotected_cons_2 %>%
  tidyterra::rename(fw_sum_richness = "fw_richness")
# fw habitat diversity by parcel
notprotected_cons_3 <- notprotected_cons_2 %>%
  terra::extract(fw_rast_stack, ., 
                 max, 
                 na.rm = TRUE,
                 bind = TRUE) 

#### Convert to sf for better data.frame utilities ####
notprotected_cons_vals_sf <- notprotected_cons_3 %>%
  st_as_sf() %>%
  tidyr::replace_na(list( # Replace NAs with 0 in freshwater columns
    riparian = 0, 
    streams = 0, 
    lakes = 0, 
    ponds = 0, 
    wetlands = 0
  )) %>% 
  mutate(fw_num_hab_pres = rowSums(across(names(fw_rast_stack)), na.rm = T)) # Get number of habitat types in each parcel


#### PLOTTING ####
# Quick plot to check
ggplot(notprotected_cons_vals_sf) +
  geom_sf(aes(fill = fw_num_hab_pres))

# Caption for all maps
caption <- paste0("Map created: ", date(), ". Palen Lab. Created by Jay Matsushiba (jmatsush@sfu.ca)")

# Conservation Vals Continuous
conservation_vals_cont_gg <- function() {
  notprotected_public_colour <-  "green"
  notprotected_private_colour <- "red"
  list(
    geom_sf(data = notprotected_cons_vals_sf, aes(fill = rankmap), color = NA),
    scale_fill_viridis_c(),
    geom_sf(data = notprotected_privatelands, aes(colour = notprotected_private_colour), linewidth = 0.3, fill = NA),
    geom_sf(data = notprotected_publiclands, aes(colour = notprotected_public_colour), linewidth = 0.3, fill = NA),
    scale_colour_identity(
      name = "",
      breaks = c(notprotected_public_colour, notprotected_private_colour),
      labels = c("Unprotected Public", "Unprotected Private"),
      guide = "legend"
    ),
    ggnewscale::new_scale_fill(),
    ggnewscale::new_scale_colour()
  )
}
conservation_vals_cont_ggplot <- bowen_map_ggplot(
  conservation_vals_cont_gg,
  title = "Conservation Values by Unprotected Parcels",
  subtitle = "Mapping the unprotected parcels and their relative biodiversity values to identify potential parcels for future protection.",
  caption = caption
)
ggplot2::ggsave(
  here(output_dir, "/", paste0(Sys.Date(), "_conservation_vals_continuous_parcels.png")),
  conservation_vals_cont_ggplot,
  device = ragg::agg_png,
  width = 9, height = 12, units = "in", res = 300
)

# Conservation Vals Top 30
conservation_vals_top_gg <- function() {
  notprotected_public_colour <-  "green"
  notprotected_private_colour <- "red"
  list(
    geom_sf(data = notprotected_cons_vals_sf, aes(fill = rankmap_top_30), color = NA),
    scale_fill_viridis_c(),
    geom_sf(data = notprotected_privatelands, aes(colour = notprotected_private_colour), linewidth = 0.3, fill = NA),
    geom_sf(data = notprotected_publiclands, aes(colour = notprotected_public_colour), linewidth = 0.3, fill = NA),
    scale_colour_identity(
      name = "",
      breaks = c(notprotected_public_colour, notprotected_private_colour),
      labels = c("Unprotected Public", "Unprotected Private"),
      guide = "legend"
    ),
    ggnewscale::new_scale_fill(),
    ggnewscale::new_scale_colour()
  )
}
conservation_vals_top_ggplot <- bowen_map_ggplot(
  conservation_vals_top_gg,
  title = "Top Conservation Values by Unprotected Parcels",
  subtitle = "Mapping the unprotected parcels and number of top 30% conservation value cells to identify potential parcels for future protection.",
  caption = caption
)
ggplot2::ggsave(
  here(output_dir, "/", paste0(Sys.Date(), "_conservation_vals_top_parcels.png")),
  conservation_vals_top_ggplot,
  device = ragg::agg_png,
  width = 9, height = 12, units = "in", res = 300
)

# Freshwater sum richness
freshwater_sum_gg <- function() {
  notprotected_public_colour <-  "green"
  notprotected_private_colour <- "red"
  list(
    geom_sf(data = notprotected_cons_vals_sf, aes(fill = fw_sum_richness), color = NA),
    scale_fill_viridis_c(),
    geom_sf(data = notprotected_privatelands, aes(colour = notprotected_private_colour), linewidth = 0.3, fill = NA),
    geom_sf(data = notprotected_publiclands, aes(colour = notprotected_public_colour), linewidth = 0.3, fill = NA),
    scale_colour_identity(
      name = "",
      breaks = c(notprotected_public_colour, notprotected_private_colour),
      labels = c("Unprotected Public", "Unprotected Private"),
      guide = "legend"
    ),
    ggnewscale::new_scale_fill(),
    ggnewscale::new_scale_colour()
  )
}
freshwater_sum_ggplot <- bowen_map_ggplot(
  freshwater_sum_gg,
  title = "Relative Freshwater Habitat Richness by Unprotected Parcels",
  subtitle = "Mapping the unprotected parcels and the total sum of freshwater habitat richness cells to identify potential parcels for future protection.",
  caption = caption
)
ggplot2::ggsave(
  here(output_dir, "/", paste0(Sys.Date(), "_fw_sum_richness_parcels.png")),
  freshwater_sum_ggplot,
  device = ragg::agg_png,
  width = 9, height = 12, units = "in", res = 300
)
# Freshwater num habitats richness
freshwater_num_hab_gg <- function() {
  notprotected_public_colour <-  "green"
  notprotected_private_colour <- "red"
  list(
    geom_sf(data = notprotected_cons_vals_sf, aes(fill = fw_num_hab_pres), color = NA),
    scale_fill_viridis_c(),
    geom_sf(data = notprotected_privatelands, aes(colour = notprotected_private_colour), linewidth = 0.3, fill = NA),
    geom_sf(data = notprotected_publiclands, aes(colour = notprotected_public_colour), linewidth = 0.3, fill = NA),
    scale_colour_identity(
      name = "",
      breaks = c(notprotected_public_colour, notprotected_private_colour),
      labels = c("Unprotected Public", "Unprotected Private"),
      guide = "legend"
    ),
    ggnewscale::new_scale_fill(),
    ggnewscale::new_scale_colour()
  )
}
freshwater_num_hab_ggplot <- bowen_map_ggplot(
  freshwater_num_hab_gg,
  title = "Number of Freshwater Habitats in Unprotected Parcels",
  subtitle = "Mapping the unprotected parcels and number of freshwater habitat types present to identify potential parcels for future protection.",
  caption = caption
)
ggplot2::ggsave(
  here(output_dir, "/", paste0(Sys.Date(), "_fw_num_hab_parcels.png")),
  freshwater_num_hab_ggplot,
  device = ragg::agg_png,
  width = 9, height = 12, units = "in", res = 300
)

#### PLOTTING PUBLIC LANDS ####
# Conservation Vals Continuous
conservation_vals_cont_pub_gg <- function() {
  list(
    geom_sf(data = notprotected_cons_vals_sf[!notprotected_cons_vals_sf$OwnerType %in% c("Private", "Mixed Ownership", "Unclassified"),] , aes(fill = rankmap), color = NA),
    scale_fill_viridis_c(),
    ggnewscale::new_scale_fill(),
    ggnewscale::new_scale_colour()
  )
}
conservation_vals_cont_pub_ggplot <- bowen_map_ggplot(
  conservation_vals_cont_pub_gg,
  title = "Conservation Values by Unprotected Parcels",
  subtitle = "Mapping the unprotected parcels and their relative biodiversity values to identify potential parcels for future protection.",
  caption = caption
)
ggplot2::ggsave(
  here(output_dir, "/", paste0(Sys.Date(), "_conservation_vals_continuous_pub_parcels.png")),
  conservation_vals_cont_pub_ggplot,
  device = ragg::agg_png,
  width = 9, height = 12, units = "in", res = 300
)

# Conservation Vals Top 30
conservation_vals_top_pub_gg <- function() {
  list(
    geom_sf(data = notprotected_cons_vals_sf[!notprotected_cons_vals_sf$OwnerType %in% c("Private", "Mixed Ownership", "Unclassified"),], aes(fill = rankmap_top_30), color = NA),
    scale_fill_viridis_c(),
    ggnewscale::new_scale_fill(),
    ggnewscale::new_scale_colour()
  )
}
conservation_vals_top_pub_ggplot <- bowen_map_ggplot(
  conservation_vals_top_pub_gg,
  title = "Top Conservation Values by Unprotected Parcels",
  subtitle = "Mapping the unprotected parcels and number of top 30% conservation value cells to identify potential parcels for future protection.",
  caption = caption
)
ggplot2::ggsave(
  here(output_dir, "/", paste0(Sys.Date(), "_conservation_vals_top_pub_parcels.png")),
  conservation_vals_top_pub_ggplot,
  device = ragg::agg_png,
  width = 9, height = 12, units = "in", res = 300
)

# Freshwater sum richness
freshwater_sum_pub_gg <- function() {
  list(
    geom_sf(data = notprotected_cons_vals_sf[!notprotected_cons_vals_sf$OwnerType %in% c("Private", "Mixed Ownership", "Unclassified"),], aes(fill = fw_sum_richness), color = NA),
    scale_fill_viridis_c(),
    ggnewscale::new_scale_fill(),
    ggnewscale::new_scale_colour()
  )
}
freshwater_sum_pub_ggplot <- bowen_map_ggplot(
  freshwater_sum_pub_gg,
  title = "Relative Freshwater Habitat Richness by Unprotected Parcels",
  subtitle = "Mapping the unprotected parcels and the total sum of freshwater habitat richness cells to identify potential parcels for future protection.",
  caption = caption
)
ggplot2::ggsave(
  here(output_dir, "/", paste0(Sys.Date(), "_fw_sum_richness_pub_parcels.png")),
  freshwater_sum_pub_ggplot,
  device = ragg::agg_png,
  width = 9, height = 12, units = "in", res = 300
)
# Freshwater num habitats richness
freshwater_num_hab_pub_gg <- function() {
  list(
    geom_sf(data = notprotected_cons_vals_sf[!notprotected_cons_vals_sf$OwnerType %in% c("Private", "Mixed Ownership", "Unclassified"),], aes(fill = fw_num_hab_pres), color = NA),
    scale_fill_viridis_c(),
    ggnewscale::new_scale_fill(),
    ggnewscale::new_scale_colour()
  )
}
freshwater_num_hab_pub_ggplot <- bowen_map_ggplot(
  freshwater_num_hab_pub_gg,
  title = "Number of Freshwater Habitats in Unprotected Parcels",
  subtitle = "Mapping the unprotected parcels and number of freshwater habitat types present to identify potential parcels for future protection.",
  caption = caption
)
ggplot2::ggsave(
  here(output_dir, "/", paste0(Sys.Date(), "_fw_num_hab_pub_parcels.png")),
  freshwater_num_hab_pub_ggplot,
  device = ragg::agg_png,
  width = 9, height = 12, units = "in", res = 300
)
```

## Crown Land - Outside of Parcels
### Polygon extent of unprotected crown land not in parcels 
```{r}
# Dissolve protected areas into one geometry
dissolved_protectedareas <- bowen_protectedareas_valid %>%
  summarise() %>%
  st_cast() %>%
  st_buffer(1) 

crown_valid <- crown %>% 
  st_snap(x = ., y = ., tolerance = 0.1) %>%
  st_make_valid() 
notprotected_crown <- st_difference(crown_valid, dissolved_protectedareas)

# Manually check each crown land polygon
for(i in 1:nrow(notprotected_crown)) {
  plot(notprotected_crown[i,])
}
# Remove polygons that should not be included in notprotected areas 
# rowname 1 (Fairy Fen Natural Reserve), sliver
# rowname 74 (Seymour Bay Park), wrong polygon in the first place
notprotected_crown_clean <- notprotected_crown[!rownames(notprotected_crown) %in% c("1","74"),]
```
### Identify potential protected areas within crown land not in parcels
Rasterize layer
Identify candidate protected areas
Two ways that crown land can be good candidates
1. High value pixels that are contiguous with other protected areas
Things that fall under the top 30% are adjacent to protected areas 
Ex. large areas west of Killarney Lake, northeast corner of Bowen Island, 


2. Contiguous pixels of high value that are not connected to protected areas 
Large enough for arguing for protection, 10 to 50 hectares or bigger

Great place to start using prioritizr! 
https://prioritizr.net/

#### Inputs
```{r}
bowen_mask_broken <- rast(here("inst/extdata/bowen_mask.tif")) %>%
  project(zonation)
# for some reason, when bowen_mask is reprojected to match the zonation
# raster, it ends up changing NA values to an extremely large number. 
# probably some bit rollover issue?
plot(bowen_mask_broken, main = "Broken Bowen Mask")
bowen_mask_broken %>%
  values() %>%
  max() # 4294967296
# this value is the highest unsigned 32-bit integer
# https://github.com/rspatial/terra/issues/1356
# seems like this issue has been reported, but not fixed

# planning units
bowen_mask <- rast(here("inst/extdata/bowen_mask.tif")) %>%
  project(zonation) %>% 
  mask(zonation) 
```

#### Prioritizr for 30% protected on Bowen Island
```{r}
# calculate budget, get prop of pixels of planning units
prop_pixels <- 0.3 # for some reason, this provides weird results when not large enough
budget <- terra::global(bowen_mask, "sum", na.rm = T)[[1]] * prop_pixels # 1594.2

# create problem
p1 <- problem(bowen_mask, features = zonation) %>%
  add_min_shortfall_objective(budget) %>%
  add_relative_targets(1) %>% # need to be at least double the budget
  # since we only have one feature, this target is meaningless but is a
  # requirement for priortizr to work 
  add_binary_decisions() %>%
  add_default_solver(gap = 0.05, verbose = FALSE) 
  # gap needs to be smaller than the difference between prop_pixels and locked constraints
  # if this is not, leads to nonsensical solutions 
  # gap value is the % from optimal
  # therefore, if gap is too large, then any solution is close enough to optimal

# print conservation problem
print(p1)

presolve_check(p1)
s1 <- solve(p1, force = T)

# extract the objective
print(attr(s1, "objective"))

# compare plots, check for agreement between priortizr and zonation
plot(s1, main = "Priortizr Solution", axes = FALSE)
remove_by_quantile(zonation, 1 - prop_pixels) %>%
  plot(main = "Top Zonation Pixels")

# check for number of cells 
s1 %>% values() %>% sum(na.rm = T) # 265 cells selected
# it works! basic top pixels identified, and agrees with zonation
# the main goal is to not use priortizr for conservation values
# the goal is to use the constraints and penalties that are part 
# of the package

# Existing Protected Areas
bowen_protectedareas %>% plot() 
# trying removing covenants, since very fragmented
bowen_pa_vect <- bowen_protectedareas[bowen_protectedareas$type != "Covenants",] %>%
  vect() %>%
  project(bowen_mask)
bowen_pa_rast <- bowen_pa_vect %>%
  rasterize(
    bowen_mask, 
    background = 0,
    # touches = T,
    cover = T
  ) %>%
  # Reclassify, greater than 50% coverage counts as protected cell
  classify(
    matrix(
      c(0, 0.5, 0, 
        0.5, 2, 1),
      ncol = 3, byrow = T
    ), 
    include.lowest = T
  ) %>%
  mask(bowen_mask) 
bowen_pa_rast_orig <- bowen_pa_vect %>%
  rasterize(
    bowen_mask, 
    background = 0,
    touches = T,
  ) %>%
  mask(bowen_mask) 

bowen_pa_cell_count <- bowen_pa_rast %>%
  values() %>%
  sum(na.rm = T)
bowen_pa_prop <- bowen_pa_cell_count / sum(values(bowen_mask), na.rm = T)

plot(bowen_pa_rast, main = "Existing Protected Areas")

# create new problem with locked in constraints 
p2 <- 
  p1 %>%
  add_locked_in_constraints(bowen_pa_rast)

s2 <- solve(p2, force = T)
plot(s2, main = "Solution with Existing Protected Areas")

# Crown land
## Combine analysis with parcels
crown_rast <- crown %>%
  vect() %>%
  project(bowen_mask) %>%
  rasterize(bowen_mask, background = 0, touches = T) %>%
  mask(bowen_mask)
notprotected_publiclands_rast <- notprotected_publiclands %>%
  vect() %>%
  project(bowen_mask) %>%
  rasterize(bowen_mask, background = 0, touches = T) %>%
  mask(bowen_mask)

# need to make sure it includes the protected areas, to work as locked-in constraint
crown_pa <- max(c(crown_rast, bowen_pa_rast, notprotected_publiclands_rast))

# reverse for locked out constraints
m <- rbind(
  c(0, 1),
  c(1, 0)
)

lockedout <- crown_pa %>%
  classify(m)

# create new problem with locked out constraints
p3 <-
  p2 %>%
  add_locked_out_constraints(lockedout)
s3 <- solve(p3, force = T)
plot(s3, main = "Solution with PA and Crown")

# add boundary penalties
p4 <-
  p3 %>%
  add_boundary_penalties(penalty = 0.000001, edge_factor = 0.5)
s4 <- solve(p4, force = T)
s4 %>% values() %>% sum(na.rm = T) # 1593
# the total pixels selected under no boundary penalty is 1594
# therefore, with this penalty value of 0.000001
# boundary penalty has an effect, but not overly so that 
# step just selects pixels around existing protected areas

plot(s4, main = "Solution with PA, Crown, and Boundary")

# importance scores
imp <- 
  p4 %>%
  eval_rank_importance(s4, n = 5, force = T)
print(imp)
imp <- terra::mask(imp, s4, maskvalues = 0, updatevalue = -1)
plot(imp, main = "Importance Scores")

# remove existing protected areas 
imp_clean <- ifel((imp - 2 * bowen_pa_rast) <= 0.1, yes = NA, no = 1) 
```
#### Checking for boundary penalty sensitivity
```{r}
# Try plotting a bunch of different boundary penalties
penalties <- seq(from = 0, to = 0.00002, by = 0.0000001)

dir.create(here(output_dir, "/boundary_penalty_check_03/"))
for(i in 1:length(penalties)) {
 # add boundary penalties
  p4 <- p3 %>%
    add_boundary_penalties(penalty = penalties[i], edge_factor = 0.5)
  s4 <- solve(p4, force = T)
  png(here(output_dir, "/boundary_penalty_check_03/", paste0(Sys.Date(), "_", i, "_boundary_penalty.png")), width = 800, height = 600)
  plot(s4, main = paste0("Solution with PA, Crown, and Boundary. Boundary Penalty = ", penalties[i]))
  polys(bowen_pa_vect, col = "orange")
  dev.off()
}
```

#### Comparison with top 30% in Zonation
In summary, the potential protected areas covers 8.2% of Bowen Island, while increasing the proportion of the top 30% zonation pixels that are protected by 13.3%. In comparison, the existing protected areas cover 19.5% of Bowen Island, while protecting 26.7% of the top 30% of zonation pixels. Therefore, these potential protected areas are more efficient at protecting the top biodiversity areas per unit area. 

```{r}
# Potential protected areas
imp_clean %>% plot()
# Existing protected areas
bowen_pa_rast_1 <- bowen_pa_rast %>%
  classify(cbind(0, NA)) 
bowen_pa_rast_1 %>% plot()
# Zonation top 30% 
zonation_top_30 <- remove_by_quantile(zonation, 1 - prop_pixels) %>%
  classify(matrix(c(0, 1, 1), ncol = 3, byrow = T))
zonation_top_30 %>% plot()

# Top 30% zonation coverage by potential PA
n_pot_pa_zon <- (imp_clean * zonation_top_30) %>% 
  values() %>% 
  sum(na.rm = T) 
prop_pot_pa_zon <- n_pot_pa_zon / sum(values(zonation_top_30), na.rm = T) # 0.1336261
prop_pot_pa_area <- sum(values(imp_clean), na.rm = T) / sum(values(bowen_mask), na.rm = T) # 0.08167106
prop_pot_pa_zon / prop_pot_pa_area # Relative value of each pixel for protecting top 30% zonation = 1.63615
# Top 30% zonation coverage by existing PA
n_exi_pa_zon <- (bowen_pa_rast_1 * zonation_top_30) %>% 
  values() %>% 
  sum(na.rm = T) 
prop_exi_pa_zon <- n_exi_pa_zon / sum(values(zonation_top_30), na.rm = T) # 0.2672522
prop_exi_pa_area <- sum(values(bowen_pa_rast_1), na.rm = T) / sum(values(bowen_mask), na.rm = T) # 0.1951449
prop_exi_pa_zon / prop_exi_pa_area # Relative value of each pixel for protecting top 30% zonation = 1.369506

# Total coverage of top 30% zonation by new and existing PA
prop_pot_pa_zon + prop_exi_pa_zon # 0.4008783
```


#### Prioritizr for 50% protected on Bowen Island
Conclusion after running this analysis - seems like this doesn't output potential protected areas that are useful. 50% coverage on Bowen Island is too close to all public lands being protected, so running the prioritizr analysis doesn't really output a meaningful result. 

The budget (total cells to select) is 2657 at 50% of Bowen Island. The total valid cells which could be protected is 2926. 

```{r}
# calculate budget, get prop of pixels of planning units
prop_pixels <- 0.5 # for some reason, this provides weird results when not large enough
budget <- terra::global(bowen_mask, "sum", na.rm = T)[[1]] * prop_pixels # 2657

# create problem
p1 <- problem(bowen_mask, features = zonation) %>%
  add_min_shortfall_objective(budget) %>%
  add_relative_targets(1) %>% # need to be at least double the budget
  # since we only have one feature, this target is meaningless but is a
  # requirement for priortizr to work 
  add_binary_decisions() %>%
  add_default_solver(gap = 0.05, verbose = FALSE) 
  # gap needs to be smaller than the difference between prop_pixels and locked constraints
  # if this is not, leads to nonsensical solutions 
  # gap value is the % from optimal
  # therefore, if gap is too large, then any solution is close enough to optimal

# print conservation problem
print(p1)

presolve_check(p1)
s1 <- solve(p1, force = T)

# extract the objective
print(attr(s1, "objective"))

# compare plots, check for agreement between priortizr and zonation
plot(s1, main = "Priortizr Solution", axes = FALSE)
remove_by_quantile(zonation, 1 - prop_pixels) %>%
  plot(main = "Top Zonation Pixels")

# check for number of cells 
s1 %>% values() %>% sum(na.rm = T) # 265 cells selected
# it works! basic top pixels identified, and agrees with zonation
# the main goal is to not use priortizr for conservation values
# the goal is to use the constraints and penalties that are part 
# of the package

# Existing Protected Areas
bowen_protectedareas %>% plot() 
# trying removing covenants, since very fragmented
bowen_pa_vect <- bowen_protectedareas[bowen_protectedareas$type != "Covenants",] %>%
  vect() %>%
  project(bowen_mask)
bowen_pa_rast <- bowen_pa_vect %>%
  rasterize(
    bowen_mask, 
    background = 0,
    # touches = T,
    cover = T
  ) %>%
  # Reclassify, greater than 50% coverage counts as protected cell
  classify(
    matrix(
      c(0, 0.5, 0, 
        0.5, 2, 1),
      ncol = 3, byrow = T
    ), 
    include.lowest = T
  ) %>%
  mask(bowen_mask) 
bowen_pa_rast_orig <- bowen_pa_vect %>%
  rasterize(
    bowen_mask, 
    background = 0,
    touches = T,
  ) %>%
  mask(bowen_mask) 

bowen_pa_cell_count <- bowen_pa_rast %>%
  values() %>%
  sum(na.rm = T)
bowen_pa_prop <- bowen_pa_cell_count / sum(values(bowen_mask), na.rm = T)

plot(bowen_pa_rast, main = "Existing Protected Areas")

# create new problem with locked in constraints 
p2 <- 
  p1 %>%
  add_locked_in_constraints(bowen_pa_rast)

s2 <- solve(p2, force = T)
plot(s2, main = "Solution with Existing Protected Areas")

# Crown land# Crown land
## Combine analysis with parcels
crown_rast <- crown %>%
  vect() %>%
  project(bowen_mask) %>%
  rasterize(bowen_mask, background = 0, touches = T) %>%
  mask(bowen_mask)
notprotected_publiclands_rast <- notprotected_publiclands %>%
  vect() %>%
  project(bowen_mask) %>%
  rasterize(bowen_mask, background = 0, touches = T) %>%
  mask(bowen_mask)

# need to make sure it includes the protected areas, to work as locked-in constraint
crown_pa <- max(c(crown_rast, bowen_pa_rast, notprotected_publiclands_rast))

# reverse for locked out constraints
m <- rbind(
  c(0, 1),
  c(1, 0)
)

lockedout <- crown_pa %>%
  classify(m)

# create new problem with locked out constraints
p3 <-
  p2 %>%
  add_locked_out_constraints(lockedout)
s3 <- solve(p3, force = T)
plot(s3, main = "Solution with PA and Crown")

# add boundary penalties
p4 <-
  p3 %>%
  add_boundary_penalties(penalty = 0.000001, edge_factor = 0.5)
s4 <- solve(p4, force = T)
s4 %>% values() %>% sum(na.rm = T) # 1593
# the total pixels selected under no boundary penalty is 1594
# therefore, with this penalty value of 0.000001
# boundary penalty has an effect, but not overly so that 
# step just selects pixels around existing protected areas

dir.create(here(output_dir, "/boundary_penalty_check_05/"))
for(i in 1:length(penalties)) {
 # add boundary penalties
  p4 <- p3 %>%
    add_boundary_penalties(penalty = penalties[i], edge_factor = 0.5)
  s4 <- solve(p4, force = T)
  png(here(output_dir, "/boundary_penalty_check_05/", paste0(Sys.Date(), "_", i, "_boundary_penalty.png")), width = 800, height = 600)
  plot(s4, main = paste0("Solution with PA, Crown, and Boundary. Boundary Penalty = ", penalties[i]))
  dev.off()
}

plot(s4, main = "Solution with PA, Crown, and Boundary")

# importance scores
imp <- 
  p4 %>%
  eval_rank_importance(s4, n = 5, force = T)
print(imp)
imp <- terra::mask(imp, s4, maskvalues = 0, updatevalue = -1)
plot(imp, main = "Importance Scores")

# remove existing protected areas 
imp_clean <- ifel((imp - 2 * bowen_pa_rast) <= 0.1, yes = NA, no = 1) 
```


### Plotting
```{r}
# Create raster for web application
m <- rbind(
  c(0.0100, 1),
  c(0.2575, 2),
  c(0.5050, 3),
  c(0.7525, 4),
  c(1.0000, 5),
  c(NA, NaN)
)
imp_reclass <- imp_clean %>%
  classify(m) %>%
  as.factor()
levels(imp_reclass) <- data.frame(
  id = 1:5,
  priority = c("Low", "Medium-Low", "Medium", "Medium-High", "High")
)
writeRaster(imp_reclass, here("inst/extdata/7_action/potential_protected_areas.tif"))
# Create vector for web application - existing protected areas
bowen_pa <- bowen_protectedareas[bowen_protectedareas$type != "Covenants",] %>%
  vect() %>%
  project("EPSG:4326")
writeVector(bowen_pa, here("inst/extdata/7_action/existing_protected_areas.gpkg"), overwrite = T)
# 
# # gg
# crown_poten_ggfunc <- function() {
#   protected_colour <- "#b3e2cd"
#   parcels_colour <-  "#fdcdac"
#   output <- list(
#     geom_spatraster(data = imp_clean, na.rm = T),
#     scale_fill_viridis_c(na.value = NA, name = "Protected Area Potential"),
#     ggnewscale::new_scale_fill(),
#     geom_sf(data = notprotected_publiclands, aes(fill = parcels_colour)),
#     geom_sf(data = bowen_protectedareas_valid, aes(fill = protected_colour)),
#     scale_fill_identity(name = "",
#                           breaks = c(protected_colour, parcels_colour),
#                           labels = c("Protected", "Parcels"),
#                           guide = "legend"
#     ),
#     ggnewscale::new_scale_fill(),
#     ggnewscale::new_scale_colour()
#   )
#   return(output)
# }
# crown_poten_ggplot <- bowen_map_ggplot(
#   crown_poten_ggfunc,
#   title = "Top Locations for Protected Areas (30x30)",
#   subtitle = "Mapping optimal Crown land for reaching 30x30 targets, using the conservation values analysis and existing protected areas. This output considers connectivity by applying boundary penalties, which prioritizes shorter boundaries relative to area. Currently, about 20% of Bowen Island is under some protection.",
#   caption = paste0("Map created: ", date(), ". Palen Lab. Created by Jay Matsushiba (jmatsush@sfu.ca)")
# )
# ggplot2::ggsave(
#   here(output_dir, "/", paste0(Sys.Date(), "_crown_potential.png")),
#   crown_poten_ggplot,
#   device = ragg::agg_png,
#   width = 9, height = 12, units = "in", res = 300
# )
# 
# protected_colour <- "#b3e2cd"
# parcels_colour <-  "#fdcdac"
# ggplot() +
#   geom_spatraster(data = imp_clean) +
#   scale_fill_viridis_c(na.value = NA, name = "Protected Area Potential") +
#   ggnewscale::new_scale_fill() +
#   geom_sf(data = parcels, aes(fill = parcels_colour)) +
#   geom_sf(data = bowen_protectedareas_valid, aes(fill = protected_colour)) +
#   scale_fill_identity(name = "",
#                       breaks = c(protected_colour, parcels_colour),
#                       labels = c("Protected", "Parcels"),
#                       guide = "legend"
#   ) +
#   ggnewscale::new_scale_fill() +
#   ggnewscale::new_scale_colour()

#### Load vector layers ####
bowen_pa <- here::here("inst/extdata/7_protected_areas/existing_protected_areas.gpkg") %>%
  sf::st_read()
bowen_ogma <- ogma %>%
  sf::st_transform(sf::st_crs(bowen_pa))
bowen_new_pa <- here::here("inst/extdata/7_protected_areas/new_protected_areas.gpkg") %>%
  sf::st_read() %>%
  sf::st_transform(sf::st_crs(bowen_pa))

# gg
protect_gg <- function() {
  protected_colour <- "#a1d76a"
  ogma_colour <- "beige"
  new_colour <- "orange"
  output <- list(
    geom_sf(data = bowen_pa, aes(fill = protected_colour), alpha = 0.5),
    geom_sf(data = bowen_ogma, aes(fill = ogma_colour), alpha = 0.5),
    geom_sf(data = bowen_new_pa, aes(fill = new_colour), alpha = 0.5),
    scale_fill_identity(name = "",
                          breaks = c(protected_colour, ogma_colour, new_colour),
                          labels = c("Current Protected", "Old Growth Management Areas", "Proposed Protected"),
                          guide = "legend"
    ),
    ggnewscale::new_scale_fill(),
    ggnewscale::new_scale_colour()
  )
  return(output)
}

protect_ggplot <- bowen_map_ggplot(
  protect_gg,
  title = "Top Locations for Protected Areas (30x30)",
  subtitle = "Mapping optimal Crown land for reaching 30x30 targets, using the conservation values analysis and existing protected areas. This output considers connectivity by applying boundary penalties, which prioritizes shorter boundaries relative to area. Currently, about 20% of Bowen Island is under some protection.",
  caption = paste0("Map created: ", date(), ". Palen Lab. Created by Jay Matsushiba (jmatsush@sfu.ca)")
)

ggplot2::ggsave(
  here(output_dir, "/", paste0(Sys.Date(), "_protect_ggplot.png")),
  protect_ggplot,
  device = ragg::agg_png,
  width = 9, height = 12, units = "in", res = 300
)

```

