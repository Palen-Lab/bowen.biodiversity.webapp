---
title: "protected_areas"
format: html
---

# Protected Areas Candidates
First map / filter
- Public lands (crown, municipal, MV lands)
- Not in existing protected areas

Second map / filter
- Top 30% of conservation values 
- Wetland / water / riparian values
 
Algorithms in Zonation and Marxann for identifying these 
- Find cluster

```{r setup}
library(bowen.biodiversity.webapp)
library(sf)
library(terra)
library(tidyterra)
library(dplyr)
library(tidyr)
library(ggplot2)
library(here)
library(googlesheets4)

sdm_url <- "https://docs.google.com/spreadsheets/d/1IGFwkr9LidcZwbzOJJGSEXLsmpKp0a9gBs65EY-H1xw/edit?usp=sharing"
habitats_url <- "https://docs.google.com/spreadsheets/d/1yDKw4r3tbXYivwtxbbfxc-pYSbtbj_o2ee1pwlNCOO4/edit?usp=drive_link"
output_dir <- here("vignettes/figures/protected_areas")
if(!dir.exists(output_dir)) {
  dir.create(output_dir)
}

#### CREATE DATAFRAME FOR INPUT LAYERS ####
# Read from Google Sheets
habitats_df <- read_sheet(habitats_url, sheet = "2025-05-02")
habitats_df$weight <- habitats_df$weight / nrow(habitats_df)
sdm_df <- read_sheet(sdm_url, sheet = "2025-05-02") 
sdm_df$weight <- sdm_df$weight / nrow(sdm_df)
# Bind all input layers together
layers_df <- sdm_df %>%
  select(colnames(habitats_df)) %>% # Select common columns
  bind_rows(habitats_df) %>%
  filter(weight > 0)

```

## First filter for Potential Protected Area Candidates
Find public lands that are not in existing protected areas
```{r}
parcels <- bowen_parcelmap %>%
  # filter(!OwnerType %in% c("Private", "Unclassified", "Mixed Ownership")) %>%
  filter(PID != 31243550) %>% # Remove ferry route 
  st_transform(st_crs(bowen_protectedareas))

parcels$geom <- parcels$geom %>%
  st_cast("MULTIPOLYGON") %>%
  st_make_valid()

bowen_protectedareas_valid <- bowen_protectedareas %>%
  st_make_valid()

# tried st_join
parcels_protected <- st_join(parcels, bowen_protectedareas_valid, largest = T)

ggplot(parcels_protected) +
  geom_sf(aes(fill = type))

ggplot(bowen_parcelmap) +
  geom_sf()
ggplot() +
  geom_sf(data = parcels, fill = "red") +
  geom_sf(data = bowen_protectedareas, fill = "green")


# Decided that the st_join is not very accurate
# Parcels are too different
# st_join overestimates the protected area (ex. a private lot with a covenant appears as entirely protected)

#### trying clip instead ####
test <- st_difference(parcels, bowen_protectedareas_valid)
# this seems wrong, ends up with 551618 observations compared to 2388 expected at most

# Dissolve protected areas into one geometry
dissolved_protectedareas <- bowen_protectedareas_valid %>%
  summarise() %>%
  st_cast() %>%
  st_buffer(1) # cleans up slivers compared to 0, buffer distance in metres
class(dissolved_protectedareas) # sf data.frame

notprotected_parcels <- st_difference(parcels, dissolved_protectedareas)
plot(notprotected_parcels[1])
plot(public_lands[1])


# filter for public lands 
notprotected_parcels$OwnerType %>% unique()
# [1] "Private"          "Crown Provincial" "Local Government" "Mixed Ownership"  "Crown Agency"     "Federal"         
# [7] "Unclassified" 
notprotected_publiclands <- notprotected_parcels[!notprotected_parcels$OwnerType %in% c("Private", "Mixed Ownership", "Unclassified"),] 
notprotected_privatelands <- notprotected_parcels[notprotected_parcels$OwnerType %in% c("Private", "Mixed Ownership", "Unclassified"),] 

potential_protected_areas_ggfunc <- function() {
  protected_colour <- "#b3e2cd"
  notprotected_public_colour <-  "#fdcdac"
  notprotected_private_colour <- "#cbd5e8"
  output <- list(
    geom_sf(data = bowen_protectedareas_valid, aes(fill = protected_colour)),
    geom_sf(data = notprotected_publiclands, aes(fill = notprotected_public_colour)),
    geom_sf(data = notprotected_privatelands, aes(fill = notprotected_private_colour)),
    scale_fill_identity(name = "",
                          breaks = c(protected_colour, notprotected_public_colour, notprotected_private_colour),
                          labels = c("Protected", "Unprotected Public", "Unprotected Private"),
                          guide = "legend"
    ),
    ggnewscale::new_scale_fill(),
    ggnewscale::new_scale_colour()
  )
  return(output)
}

caption <- paste0("Map created: ", date(), ". Palen Lab. Created by Jay Matsushiba (jmatsush@sfu.ca)")
protected_areas_ggplot <- bowen_map_ggplot(
  potential_protected_areas_ggfunc,
  title = "Protected Areas and Parcels on Bowen Island",
  subtitle = "Mapping the Protected Areas and unprotected parcels to identify potential parcels for future protection.",
  caption = caption
)


ggplot2::ggsave(
  here(output_dir, "/", paste0(Sys.Date(), "_protected_areas_parcels.png")),
  protected_areas_ggplot,
  device = ragg::agg_png,
  width = 9, height = 12, units = "in", res = 300
)
```

## Second filter 
- Top 30% of conservation values 
- Wetland / water / riparian values
```{r}
# Load Zonation
zonation <- here("inst/extdata/output_zonation/2025-05-02/rankmap.tif") %>%
  rast()

#### Conservation values summed by parcel ####
# extract zonation raster values from cells within each parcel
notprotected_cons_vals <- notprotected_parcels %>% 
  vect() %>%
  terra::extract(zonation, ., 
                 sum, 
                 na.rm = TRUE, 
                 weights = TRUE, # sum biodiversity value by approx fraction of cell covered by polygon
                 bind = TRUE) 

#### Top 30% conservation values summed by parcel ####
# create top 30% zonation raster 
rcl <- matrix(c(
  0, 1, 1
), ncol = 3, byrow = T)
zonation_top_30 <- zonation %>%
  remove_by_quantile(
    prob = 0.7
  ) %>% 
  classify(rcl)
names(zonation_top_30) <- "rankmap_top_30"
# extract number of top conservation value cells within each parcel
notprotected_cons_1 <- notprotected_cons_vals %>%
  terra::extract(zonation_top_30, ., 
                 sum, 
                 na.rm = TRUE, 
                 weights = TRUE, # sum biodiversity value by approx fraction of cell covered by polygon
                 bind = TRUE) 

#### Freshwater (wetland, ponds, rivers) ####
# Get freshwater rasters, same used in zonation and data atlas
fw_df <- layers_df[layers_df$category == "Freshwater",]
fw_rast_stack <- layers_df[layers_df$category == "Freshwater", "path"] %>%
  unlist() %>%
  lapply(rast) %>%
  rast() 
fw_rast_stack %>% sources() # see order of paths 
names(fw_rast_stack) <- c("riparian", "streams", "lakes", "ponds", "wetlands") # assign names to layers
# TODO: decide what to do with stream classes, leave them as is?
# 3 is fish-bearing streams, 2 is tributary to fish-bearing, 1 is non-fishbearing / drainage channel / unclassified 

fw_richness <- fw_rast_stack %>%
  lapply(not.na) %>%
  lapply(function(x) {classify(x, cbind(FALSE, NA))}) %>%
  rast() %>%
  sum(na.rm = T) 
names(fw_richness) <- "fw_richness"
# summed richness by parcel
notprotected_cons_2 <- notprotected_cons_1 %>%
  terra::extract(fw_richness, ., 
                 sum, 
                 na.rm = TRUE, 
                 weights = TRUE, # sum biodiversity value by approx fraction of cell covered by polygon
                 bind = TRUE) 
notprotected_cons_2 <- notprotected_cons_2 %>%
  tidyterra::rename(fw_sum_richness = "fw_richness")
# fw habitat diversity by parcel
notprotected_cons_3 <- notprotected_cons_2 %>%
  terra::extract(fw_rast_stack, ., 
                 max(), 
                 na.rm = TRUE,
                 bind = TRUE) 

#### Convert to sf for better data.frame utilities ####
notprotected_cons_vals_sf <- notprotected_cons_3 %>%
  st_as_sf() %>%
  tidyr::replace_na(list( # Replace NAs with 0 in freshwater columns
    riparian = 0, 
    streams = 0, 
    lakes = 0, 
    ponds = 0, 
    wetlands = 0
  )) %>% 
  mutate(fw_num_hab_pres = rowSums(across(names(fw_rast_stack)), na.rm = T)) # Get number of habitat types in each parcel


# Plot to check
ggplot(notprotected_cons_vals_sf) +
  geom_sf(aes(fill = fw_num_hab_pres))
```

